//! Provides [Strategy] and [ValueTree] adapters for generating
//! [std::Option] values.
//!
//! The structures in this module are very similar to those
//! in [proptest::option].

use std::fmt::Debug;

use proptest::strategy::{NewTree, Strategy, ValueTree};
use proptest::test_runner::TestRunner;

/// Strategy which generates [Option] values whose
/// inner [Some] value are generated by another strategy.
///
/// This is likely distinct from [proptest::option::OptionStrategy]
/// only in its [Strategy::Tree] type.
#[derive(Clone, Debug)]
pub struct Maybe<T>(pub T);

impl<T> Strategy for Maybe<T>
where
    T: Debug + Strategy,
    <T as Strategy>::Tree: Debug,
{
    type Tree = MaybeValueTree<<T as Strategy>::Tree>;
    type Value = Option<T::Value>;

    fn new_tree(&self, runner: &mut TestRunner) -> NewTree<Self> {
        Ok(MaybeValueTree::new(self.0.new_tree(runner)?))
    }
}

/// [ValueTree] type which shrinks an optional value.
///
/// This is produced by the [Maybe] strategy adapter.
///
/// The difference from [proptest::option::OptionValueTree]
/// is that this has a public constructor which allows it
/// to adapt any other [ValueTree].
#[derive(Clone, Debug)]
pub struct MaybeValueTree<T> {
    inner: T,
    state: MaybeState,
}

impl<T> MaybeValueTree<T> {
    pub fn new(value: T) -> Self {
        MaybeValueTree {
            inner: value,
            state: MaybeState::New,
        }
    }
}

/// Search state for shrinking a [MaybeValueTree].
#[derive(Clone, Debug)]
enum MaybeState {
    /// No values have been produced yet. Try [Some] of the initial inner input.
    New,
    /// The initial inner input failed. Try [None].
    TryNone,
    /// Final state indicating that [None] is a failing input.
    /// In this state, [None] is always the value produced.
    NoneFailed,
    /// Final state indicating that [Some] is a failing input.
    /// In this state, [Some] is always the value produced,
    /// holding a value produced as we search the inner [ValueTree].
    NonePassed,
}

impl<T> ValueTree for MaybeValueTree<T>
where
    T: Debug + ValueTree,
{
    type Value = Option<<T as ValueTree>::Value>;

    fn current(&self) -> Self::Value {
        match self.state {
            MaybeState::TryNone => None,
            _ => Some(self.inner.current()),
        }
    }

    fn simplify(&mut self) -> bool {
        match self.state {
            MaybeState::New => {
                // the initial output was Some of the initial
                self.state = MaybeState::TryNone;
                true
            }
            MaybeState::TryNone => {
                // `None` failed, no way to get simpler
                self.state = MaybeState::NoneFailed;
                false
            }
            MaybeState::NoneFailed => {
                // we have already found the simplest failing input
                false
            }
            MaybeState::NonePassed => {
                // `None` is not the simplest so defer to inner
                self.inner.simplify()
            }
        }
    }

    fn complicate(&mut self) -> bool {
        match self.state {
            MaybeState::New => {
                // initial input passed, this likely is just `true`
                self.inner.complicate()
            }
            MaybeState::TryNone => {
                // `None` passed, begin searching the inner value tree
                self.state = MaybeState::NonePassed;
                true
            }
            MaybeState::NoneFailed => {
                // search is over, None is the simplest failing input
                false
            }
            MaybeState::NonePassed => {
                // search the inner value
                self.inner.complicate()
            }
        }
    }
}
